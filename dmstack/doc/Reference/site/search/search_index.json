{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Program starting The main function do the following steps: Initializes data base. Reads command arguments. Creates a code reader. With such reader run an isolated stack machine. The stack machine read code from the file indicated in arguments and executes it.","title":"General Scheme"},{"location":"#program-starting","text":"The main function do the following steps: Initializes data base. Reads command arguments. Creates a code reader. With such reader run an isolated stack machine. The stack machine read code from the file indicated in arguments and executes it.","title":"Program starting"},{"location":"commandLine/","text":"User Interface The command line has the following structure: dmstack [Options] dmsProgram [-- dmsProgramOptions] Options: -d : Running in 'debug mode'. The only difference between 'debug mode' and 'normal mode' is that in 'debug mode' 'at directives' are read and interpreted and in 'normal mode' not. dmsProgram: Path to \".dms\" file. If this path not ends in \".dms\", such extension will be added. dmsProgramOptions: Arguments of \".dms\" code. They can be read through the procedure \"sys.args\". Examples dmstack myProg dmstack -d src/myProg.dms dmstack myProg -- -i data/data 2.tb -o result/book.txt","title":"Command Line"},{"location":"commandLine/#user-interface","text":"The command line has the following structure: dmstack [Options] dmsProgram [-- dmsProgramOptions] Options: -d : Running in 'debug mode'. The only difference between 'debug mode' and 'normal mode' is that in 'debug mode' 'at directives' are read and interpreted and in 'normal mode' not. dmsProgram: Path to \".dms\" file. If this path not ends in \".dms\", such extension will be added. dmsProgramOptions: Arguments of \".dms\" code. They can be read through the procedure \"sys.args\".","title":"User Interface"},{"location":"commandLine/#examples","text":"dmstack myProg dmstack -d src/myProg.dms dmstack myProg -- -i data/data 2.tb -o result/book.txt","title":"Examples"},{"location":"imports/","text":"Syntax There are two forms: \"modulePath\" import and (\"modulePath\" symbol) import Where: \"modulePath\" is the relative path of the file to import, without the .dms extension (relative to the calling file). The path is transformed to its canonical representation. and symbol is the symbol to represent \"modulePath\". When it is not indicated, the base of \"modulePath\" is used as symbol. Example We have the following structure, |- main.dms |- lib |- inc.dms If inc.dms has a procedure print with print an Int on screen, we can call this procedure from main.dms in any of the next ways: lib/inc import 4 inc.print ( lib/inc i) import 4 i.print Syntax Implementation The reader has a map for each file from symbols to path. Every import generates a new entry \"symbol: path\". After that following cases of \"symbol\" are replaced by \"path\". Note that a redefinition in the same file of \"symbol\" hiddes the previous one. The efective importation is made by dmstack machine , when code is processed. Working If the import has been imported, it is added to the list of imports of the current virtual machine. If the import is 'on way' an error is raised (cyclic import) Otherwaise the correponding module is read, runned in as isolate virtual machine, saved in the imports list and added to the list of imports of the current virtual machine. OnWay When a file import starts, its file path is marked as \"on way\" with the function imports.PutOnWay . When the import ends, such mark is removed with imports.QuitOnWay . To test if a path is \"on way' can be used imports.IsOnWay .","title":"Imports"},{"location":"imports/#syntax","text":"There are two forms: \"modulePath\" import and (\"modulePath\" symbol) import Where: \"modulePath\" is the relative path of the file to import, without the .dms extension (relative to the calling file). The path is transformed to its canonical representation. and symbol is the symbol to represent \"modulePath\". When it is not indicated, the base of \"modulePath\" is used as symbol. Example We have the following structure, |- main.dms |- lib |- inc.dms If inc.dms has a procedure print with print an Int on screen, we can call this procedure from main.dms in any of the next ways: lib/inc import 4 inc.print ( lib/inc i) import 4 i.print","title":"Syntax"},{"location":"imports/#syntax-implementation","text":"The reader has a map for each file from symbols to path. Every import generates a new entry \"symbol: path\". After that following cases of \"symbol\" are replaced by \"path\". Note that a redefinition in the same file of \"symbol\" hiddes the previous one. The efective importation is made by dmstack machine , when code is processed.","title":"Syntax Implementation"},{"location":"imports/#working","text":"If the import has been imported, it is added to the list of imports of the current virtual machine. If the import is 'on way' an error is raised (cyclic import) Otherwaise the correponding module is read, runned in as isolate virtual machine, saved in the imports list and added to the list of imports of the current virtual machine.","title":"Working"},{"location":"imports/#onway","text":"When a file import starts, its file path is marked as \"on way\" with the function imports.PutOnWay . When the import ends, such mark is removed with imports.QuitOnWay . To test if a path is \"on way' can be used imports.IsOnWay .","title":"OnWay"},{"location":"literals/","text":"Blank It is a character (ch) such that : ch = ' ' || ch == ';' || ch == ':' || ch == ',' Blanks are separators of tokens and are skipped by the reader. Comment There are two types: Line comment. Start with // and extends to end of line. Block comment. Starts with /* and ends with */ . There are not nested block comments. Examples: 35 : x = // This is a line comment. 12 : y = // This other line comment. /* This is a block command. */ x y + /* This is a block command too */ puts NOTE : Comments must be separated with a blank from the precedent token. However the next token can be without separation. This is incorrect: 12 : y =// This other line comment. x y +/* This is a block command too */ puts But this is correct: x y + /* This is a block command too */puts Boolean Values true and false Integer Its underline value is an integer of 64 bytes. Decimal Integer Digits sequence that can start with - . ( 0 , -0 , 142 , -4532 ). Hexadecimal Integer Hexadecimal digits (upper or lowercase) which must start with '0x'. Its digits part can start with - or + . ( 0x2f , 0x-AA , 0x+16 ) Float Its underline value is an float of 64 bytes. It is a sequence of digits whih must contain a decimal point . and can have e or E for scientific notation. ( -12.45 , -0. , -11.e1 , 23.4E-3 , 45.e+2 . NOTE : A float can not start with a point. In such case is interpreted as an object key. The decimal point is mandatory. For example -11e1 throws an error, but -11.e1 is correct. String Normal Strings They are sequences of UTF-8 symbols between quotes. The following escape sequences are allowed: \\\" , \\\\ , \\t , \\n , \\r , \\b , \\f and \\uXXXX (Hexadecimal unicode character). Charancter with integer value less than \" \"(space) are not allowed. Therefore this strings can not be extended more than one line. \"HereDoc\" Strings This string starts with `symbol\\n and ends with symbol` . symbol is optional. This strings have not escape sequences and allows any type of UTF-8 character. Examples ` a multiline string.` produces \"a multiline\\nstring\" . `TX-- a `multiline` string.--TX` produces \"a `multiline`\\nstring\" . But `a multiline string.` produces an error. String Interpolation Both string classes allow interpolation. A interpolation is a expresion of type ${value} , where value is a expresion which is calculated with data and must returns no value or one only value. In the last case the procedure toStr will be applied to the value if it is not a String. Examples \"2 + 2 = ${2 2 +}\" - 2 + 2 = 4 '${}' - '' NOTE: If you want to use the literal ${ , you should use some resourece lake spliting the string or using ${$}{ . For example: \"The '$\" \"{' is a symbol\" + - The '${' is a symbol or \"The '${$}{' is a symbol\" - The '${' is a symbol Nither you can use } inside the interpolation. Symbol A symbol is any sequence of ASCII characters which integer value is greater than 32 (space) and different of , (comma), : (colon) and ; (semicolon). Symbols that contains { , } , [ , ] , ( or ) , apart of themselves, are not allowed. See Symbols . Procedure A procedure is a sequence of tokens between parentheses. Examples (4 5 +) ( 4 5 + 6 == ) List A list is a sequence of tokens between square brackets. A list is read as a Procedure and adding the reserverd word data . That is [...] is replaced by (...) data . As result tokens in the list will be evaluated by the dmstack machine . Examples [4 5 +] that is the same as [9] . [ 4 5 + 6 a ] that is the same as [9 6 \"a\"] . For better visualization is recomended to use commas: [4 5 +, 6, a ] Map A map is a sequence of tokens between curly brackets. Tokens are alternatively \"string - token\" so that its number is even. It is a list that will be converted to map . {...} is replaced by (...) data map.from . Examples { a 7 6 + b true } that is the same as {\"a\" 13 \"b\" true} . It is recomended to use : and , to improve visualization. { a : 7 6 +, b : true } or { a : 7 6 + b : true } Program It is a sequence of tokens. Example Hello World! puts","title":"Literals"},{"location":"literals/#blank","text":"It is a character (ch) such that : ch = ' ' || ch == ';' || ch == ':' || ch == ',' Blanks are separators of tokens and are skipped by the reader.","title":"Blank"},{"location":"literals/#comment","text":"There are two types: Line comment. Start with // and extends to end of line. Block comment. Starts with /* and ends with */ . There are not nested block comments. Examples: 35 : x = // This is a line comment. 12 : y = // This other line comment. /* This is a block command. */ x y + /* This is a block command too */ puts NOTE : Comments must be separated with a blank from the precedent token. However the next token can be without separation. This is incorrect: 12 : y =// This other line comment. x y +/* This is a block command too */ puts But this is correct: x y + /* This is a block command too */puts","title":"Comment"},{"location":"literals/#boolean","text":"Values true and false","title":"Boolean"},{"location":"literals/#integer","text":"Its underline value is an integer of 64 bytes.","title":"Integer"},{"location":"literals/#decimal-integer","text":"Digits sequence that can start with - . ( 0 , -0 , 142 , -4532 ).","title":"Decimal Integer"},{"location":"literals/#hexadecimal-integer","text":"Hexadecimal digits (upper or lowercase) which must start with '0x'. Its digits part can start with - or + . ( 0x2f , 0x-AA , 0x+16 )","title":"Hexadecimal Integer"},{"location":"literals/#float","text":"Its underline value is an float of 64 bytes. It is a sequence of digits whih must contain a decimal point . and can have e or E for scientific notation. ( -12.45 , -0. , -11.e1 , 23.4E-3 , 45.e+2 . NOTE : A float can not start with a point. In such case is interpreted as an object key. The decimal point is mandatory. For example -11e1 throws an error, but -11.e1 is correct.","title":"Float"},{"location":"literals/#string","text":"","title":"String"},{"location":"literals/#normal-strings","text":"They are sequences of UTF-8 symbols between quotes. The following escape sequences are allowed: \\\" , \\\\ , \\t , \\n , \\r , \\b , \\f and \\uXXXX (Hexadecimal unicode character). Charancter with integer value less than \" \"(space) are not allowed. Therefore this strings can not be extended more than one line.","title":"Normal Strings"},{"location":"literals/#heredoc-strings","text":"This string starts with `symbol\\n and ends with symbol` . symbol is optional. This strings have not escape sequences and allows any type of UTF-8 character. Examples ` a multiline string.` produces \"a multiline\\nstring\" . `TX-- a `multiline` string.--TX` produces \"a `multiline`\\nstring\" . But `a multiline string.` produces an error.","title":"\"HereDoc\" Strings"},{"location":"literals/#string-interpolation","text":"Both string classes allow interpolation. A interpolation is a expresion of type ${value} , where value is a expresion which is calculated with data and must returns no value or one only value. In the last case the procedure toStr will be applied to the value if it is not a String. Examples \"2 + 2 = ${2 2 +}\" - 2 + 2 = 4 '${}' - '' NOTE: If you want to use the literal ${ , you should use some resourece lake spliting the string or using ${$}{ . For example: \"The '$\" \"{' is a symbol\" + - The '${' is a symbol or \"The '${$}{' is a symbol\" - The '${' is a symbol Nither you can use } inside the interpolation.","title":"String Interpolation"},{"location":"literals/#symbol","text":"A symbol is any sequence of ASCII characters which integer value is greater than 32 (space) and different of , (comma), : (colon) and ; (semicolon). Symbols that contains { , } , [ , ] , ( or ) , apart of themselves, are not allowed. See Symbols .","title":"Symbol"},{"location":"literals/#procedure","text":"A procedure is a sequence of tokens between parentheses. Examples (4 5 +) ( 4 5 + 6 == )","title":"Procedure"},{"location":"literals/#list","text":"A list is a sequence of tokens between square brackets. A list is read as a Procedure and adding the reserverd word data . That is [...] is replaced by (...) data . As result tokens in the list will be evaluated by the dmstack machine . Examples [4 5 +] that is the same as [9] . [ 4 5 + 6 a ] that is the same as [9 6 \"a\"] . For better visualization is recomended to use commas: [4 5 +, 6, a ]","title":"List"},{"location":"literals/#map","text":"A map is a sequence of tokens between curly brackets. Tokens are alternatively \"string - token\" so that its number is even. It is a list that will be converted to map . {...} is replaced by (...) data map.from . Examples { a 7 6 + b true } that is the same as {\"a\" 13 \"b\" true} . It is recomended to use : and , to improve visualization. { a : 7 6 +, b : true } or { a : 7 6 + b : true }","title":"Map"},{"location":"literals/#program","text":"It is a sequence of tokens. Example Hello World! puts","title":"Program"},{"location":"stackControl/","text":"Stack control has a symbol ever allowed ( @?xxx ) and others ( @ , @xxx , @+xxx , @-xxx ) only actives if dmsatck has been called with the option '-d'. Stack Sequence Descriptor It is a sequence of characters which especify value types in the machine stack. A sequence descriptor is a sequence (possibly empty) of descriptor of type. For example: is specify Int-String -TopStack. b = File i specfiy Bool-Object File-Int -TopStack Valid values for descriptors are: b Boolean i Integer f Float s String p Procedure l List m Map y Symbol = Ob Native object \"Ob\" @?xxx The reader replaces it by \"xxx\" = @? , where \"xxx\" is a sequence descriptor. = @? returns true if the machine stack last positions match \"xxx\". For example: 4 a @?is Returns true . @? without sequence descriptor (an empty sequence descriptor) returns true if the machine stack is empty. @+xxx Only active with the option '-d'. The reader replaces it by \"xxx\" = @+ , where \"xxx\" is a sequence descriptor. = @! throws an exception if the machine stack last positions does not match \"xxx\". Otherwise push the symbol = @! on the stack before the values which match the sequence descriptor. @+ without sequence descriptor (an empty sequence descriptor) throws an exception if the machine stack is empty. Otherwise push the symbol = @! on the stack. @-xxx Only active with the option '-d'. The reader replaces it by \"xxx\" = @- , where \"xxx\" is a sequence descriptor. = @! throws an exception if the machine stack positions from = @! does notmatch \"xxx\" or if = @! is not found. Otherwise remove the symbol = @! . @- without sequence descriptor (an empty sequence descriptor) throws an exception if the machine stack is empty or if = @! is not found. Otherwise remove the symbol = @! . @xxx Only active with the option '-d'. The reader replaces it by \"xxx\" = @ , where \"xxx\" is a sequence descriptor. = @ throws an exception if the machine stack last positions does not match \"xxx\". @ without sequence descriptor (an empty sequence descriptor) throws an exception if the machine stack is empty.","title":"Stack Control"},{"location":"stackControl/#stack-sequence-descriptor","text":"It is a sequence of characters which especify value types in the machine stack. A sequence descriptor is a sequence (possibly empty) of descriptor of type. For example: is specify Int-String -TopStack. b = File i specfiy Bool-Object File-Int -TopStack Valid values for descriptors are: b Boolean i Integer f Float s String p Procedure l List m Map y Symbol = Ob Native object \"Ob\"","title":"Stack Sequence Descriptor"},{"location":"stackControl/#xxx","text":"The reader replaces it by \"xxx\" = @? , where \"xxx\" is a sequence descriptor. = @? returns true if the machine stack last positions match \"xxx\". For example: 4 a @?is Returns true . @? without sequence descriptor (an empty sequence descriptor) returns true if the machine stack is empty.","title":"@?xxx"},{"location":"stackControl/#xxx_1","text":"Only active with the option '-d'. The reader replaces it by \"xxx\" = @+ , where \"xxx\" is a sequence descriptor. = @! throws an exception if the machine stack last positions does not match \"xxx\". Otherwise push the symbol = @! on the stack before the values which match the sequence descriptor. @+ without sequence descriptor (an empty sequence descriptor) throws an exception if the machine stack is empty. Otherwise push the symbol = @! on the stack.","title":"@+xxx"},{"location":"stackControl/#-xxx","text":"Only active with the option '-d'. The reader replaces it by \"xxx\" = @- , where \"xxx\" is a sequence descriptor. = @! throws an exception if the machine stack positions from = @! does notmatch \"xxx\" or if = @! is not found. Otherwise remove the symbol = @! . @- without sequence descriptor (an empty sequence descriptor) throws an exception if the machine stack is empty or if = @! is not found. Otherwise remove the symbol = @! .","title":"@-xxx"},{"location":"stackControl/#xxx_2","text":"Only active with the option '-d'. The reader replaces it by \"xxx\" = @ , where \"xxx\" is a sequence descriptor. = @ throws an exception if the machine stack last positions does not match \"xxx\". @ without sequence descriptor (an empty sequence descriptor) throws an exception if the machine stack is empty.","title":"@xxx"},{"location":"symbols/","text":"A symbol is any sequence of ASCII characters which integer value is greater than 32 (space) and different of , (comma), : (colon) and ; (semicolon). Symbols that contains { , } , [ , ] , ( or ) , apart of themselves, are not allowed. Index There is an index where every symbol is registered. To convert a string in a symbol is necessary call symbol.New that returns returns the corresponding symbol (If the string is already registered it returns its symbol, otherwise, it adds the string to index, creates a new symbol and returns it). There are a number of symbols intially registered: if, else, nop, +, ... Symbols With Dot A symbol which does not start whith this. only can have one dot. If it start with this. , is allowed: one dot. That of this. two dots. That of this. and a final dot (e.g. this.fn. ). This construction is thought to make \"private\" procedures. If the dot is between two blanks, it is consedered a blank too. If the symbol start with this. , the next replacement is done: this.right - this right The symbol right can have a dot if it is the last character. If the symbol start with a dot the following replacement is done: .right - \"right\" map get If the symbol ends with a dot, it is treated like another normal symbol. If the dot is inner the symbol the next replacement is done: left.right - left right In this case if left is an import symbol, it will be substituted by its path. Note that, in general, you ever can write left right directly. Symbols With ! + Int These symbols are sustituted by: !number - right lst get number must be an not negative Int (e.g. l !3 - l 3 lst get ). @ Symbols They are symbols wich start with @ . Its semantics is shown in Stack Contol . @ It is substituted by: @ - stk empty? @?Types It is substituted by: @?types - \"types\" stackCheckSymbol Where types is a types defition (e.g. @?is ) and stackCheckSymbol is the reserverd symbol StackCheck = = @? @+Types It is substituted by @+types - \"types\" stackOpenSymbol Where types is a types defition (e.g. @+is ) and stackOpenSymbol is the reserverd symbol StackOpen = = @+ @-Types It is substituted by @-types - \"types\" stackCloseSymbol Where types is a types defition (e.g. @-is ) and stackCloseSymbol is the reserverd symbol StackClose = = @- @Types It is substituted by @types - \"types\" stackSymbol Where types is a types defition (e.g. @is ) and stackSymbol is the reserverd symbol Stack = = @ \"import\" Symbol This symbol receive a special treatment when reading. See Imports \"this\" Symbol This symbol is substituted by the module path symbol. Reserverd Symbols = Symbol Used after a new symbol to save a token. If the symbol is not a new one, an error will be raised. = Symbol Used after a new symbol to save an exported token. If the symbol is not a new one, an error will be raised. Global Module See API . Other Primitive Modules # Symbols Dmstack virtual machine keep a counter for singling symbols. The symbol # increments the counter. A symbol type xxx# is replaced by xxx\u00b7counter (e.g. xxx\u00b7183 ). Other Symbols They are processed in two steps: Verification if the symbol is an import. In this case it is processed as such import. It it is not an import is normaly processed.","title":"Symbols"},{"location":"symbols/#index","text":"There is an index where every symbol is registered. To convert a string in a symbol is necessary call symbol.New that returns returns the corresponding symbol (If the string is already registered it returns its symbol, otherwise, it adds the string to index, creates a new symbol and returns it). There are a number of symbols intially registered: if, else, nop, +, ...","title":"Index"},{"location":"symbols/#symbols-with-dot","text":"A symbol which does not start whith this. only can have one dot. If it start with this. , is allowed: one dot. That of this. two dots. That of this. and a final dot (e.g. this.fn. ). This construction is thought to make \"private\" procedures. If the dot is between two blanks, it is consedered a blank too. If the symbol start with this. , the next replacement is done: this.right - this right The symbol right can have a dot if it is the last character. If the symbol start with a dot the following replacement is done: .right - \"right\" map get If the symbol ends with a dot, it is treated like another normal symbol. If the dot is inner the symbol the next replacement is done: left.right - left right In this case if left is an import symbol, it will be substituted by its path. Note that, in general, you ever can write left right directly.","title":"Symbols With Dot"},{"location":"symbols/#symbols-with-int","text":"These symbols are sustituted by: !number - right lst get number must be an not negative Int (e.g. l !3 - l 3 lst get ).","title":"Symbols With ! + Int"},{"location":"symbols/#symbols","text":"They are symbols wich start with @ . Its semantics is shown in Stack Contol . @ It is substituted by: @ - stk empty? @?Types It is substituted by: @?types - \"types\" stackCheckSymbol Where types is a types defition (e.g. @?is ) and stackCheckSymbol is the reserverd symbol StackCheck = = @? @+Types It is substituted by @+types - \"types\" stackOpenSymbol Where types is a types defition (e.g. @+is ) and stackOpenSymbol is the reserverd symbol StackOpen = = @+ @-Types It is substituted by @-types - \"types\" stackCloseSymbol Where types is a types defition (e.g. @-is ) and stackCloseSymbol is the reserverd symbol StackClose = = @- @Types It is substituted by @types - \"types\" stackSymbol Where types is a types defition (e.g. @is ) and stackSymbol is the reserverd symbol Stack = = @","title":"@ Symbols"},{"location":"symbols/#import-symbol","text":"This symbol receive a special treatment when reading. See Imports","title":"\"import\" Symbol"},{"location":"symbols/#this-symbol","text":"This symbol is substituted by the module path symbol.","title":"\"this\" Symbol"},{"location":"symbols/#reserverd-symbols","text":"= Symbol Used after a new symbol to save a token. If the symbol is not a new one, an error will be raised. = Symbol Used after a new symbol to save an exported token. If the symbol is not a new one, an error will be raised. Global Module See API . Other Primitive Modules","title":"Reserverd Symbols"},{"location":"symbols/#symbols_1","text":"Dmstack virtual machine keep a counter for singling symbols. The symbol # increments the counter. A symbol type xxx# is replaced by xxx\u00b7counter (e.g. xxx\u00b7183 ).","title":"# Symbols"},{"location":"symbols/#other-symbols","text":"They are processed in two steps: Verification if the symbol is an import. In this case it is processed as such import. It it is not an import is normaly processed.","title":"Other Symbols"},{"location":"tokens/","text":"Tokens are syntax units. Each token is a serie of valid characters separated by blanks. Every token has a type and a position. The type determines which operations can be done with it. The position is a reference to the module (file) and line in which appears. Types There are the following types of tokens and its literals: Bool : Only two values. ( true , false ). Int : [-]digits. This literals have not decimal point. The character '_' is allowed to grouping. ( 0 , 34 , -115 , 2_345 - 2345 ) Float : [-]digits and decimal point. The character '_' is allowed to grouping. ( 0.0 , 34.41 , -115.16 , 2_345.2 - 2345.2 ) String : It has two formats: \" characters \" . This format can not be multiline, quotes and slashes should be escaped and allows other escaped symbols (\\n\\t...). ( \"\" , \"abc\" , \"a\\\"b\\\"d\" , \"33\u20ac\" ) ` characters ` . This format is multiline, quotes and slashes have not to be escaped. No escape symbol is processed. See more in Literals-String . Procedure : ( token token ... ) . ( () , (1 == (\"a\") (\"b\") elif) , (2 +) ). List : [ token , token , ... ] . Commas are optional. ( [] , [1, \"a\", true] , [1 \"a\" true] ). Every element is evaluated with data . Map : { key : token , key : token , ... } . key must evaluate to String. Semicolons and commas are optional. ( {} , {\"a\": 1, \"b\": true} , {\"a\" 1 \"b\" true} ). Every element is evaluated with data . Symbol : characters . They can not contain {}[]():;, nor can start with \"- or a digit (0-9). Neither can be true or false . Native : Used to represent native objects. They have not literals and must be created programmatically.","title":"Tokens"},{"location":"tokens/#types","text":"There are the following types of tokens and its literals: Bool : Only two values. ( true , false ). Int : [-]digits. This literals have not decimal point. The character '_' is allowed to grouping. ( 0 , 34 , -115 , 2_345 - 2345 ) Float : [-]digits and decimal point. The character '_' is allowed to grouping. ( 0.0 , 34.41 , -115.16 , 2_345.2 - 2345.2 ) String : It has two formats: \" characters \" . This format can not be multiline, quotes and slashes should be escaped and allows other escaped symbols (\\n\\t...). ( \"\" , \"abc\" , \"a\\\"b\\\"d\" , \"33\u20ac\" ) ` characters ` . This format is multiline, quotes and slashes have not to be escaped. No escape symbol is processed. See more in Literals-String . Procedure : ( token token ... ) . ( () , (1 == (\"a\") (\"b\") elif) , (2 +) ). List : [ token , token , ... ] . Commas are optional. ( [] , [1, \"a\", true] , [1 \"a\" true] ). Every element is evaluated with data . Map : { key : token , key : token , ... } . key must evaluate to String. Semicolons and commas are optional. ( {} , {\"a\": 1, \"b\": true} , {\"a\" 1 \"b\" true} ). Every element is evaluated with data . Symbol : characters . They can not contain {}[]():;, nor can start with \"- or a digit (0-9). Neither can be true or false . Native : Used to represent native objects. They have not literals and must be created programmatically.","title":"Types"},{"location":"virtualMachine/","text":"Structure A virtual machine processes a token of type Procedure. Each virtual machine have: A stack (implemented as a pointer to a slice of tokens). A heap (implemented as a map from symbol to token). A list of modules imported (implemented as a slice of symbols). Virtual machines can run other ones. In such case: The stack can be inherited (normal case) or not (isolate machine). The heap is never inherited. The list of modules imported is ever inherited. Working The virtual machine process a procedure token by token with the following steps: The token is a symbol: Is = ?: Raise an error. Is ?: Skip the token. Is a global symbol?: It is run. It is a primitive module?: Next token, that must be a symbol, is read and run. It is an imported module?: Next token, that must be a symbol, is read and then: If the last symbol is defined in the import: If it references a procedure: If an fallows: The procedure is pushed into the stack. Otherwise: The procedure is run. Otherwise the token referenced is pushed into the stack. Otherwise an error is raised. It is a module in heap?: If it references a procedure: If an fallows: The procedure is pushed into the stack. Otherwise: The procedure is run. Otherwise the token referenced is pushed into the stack. It is followed by = ?: The token is put into the heap. Otherwise an error is raised (\"unknown symbol\") Otherwise is pushed into the stack. NOTE: Observe that is not possible to redefine (push into heap) a symbol. Normal And Isolate Virtual Machine A normal virtual machine share its stack with the virtual machine which call it. An isolate virtual machine has its own stack. Heap Access Virtual machines create an call other virtual machines to execute procedures. This sets a hierarchy m1 - m2 - ... - mN. When a machine finds reference for a symbol, it accesses orderly the heap of every ancestor. A problem can apear when a procedure is send to be executed by other virtual machine. Let see the following program. ( fn = 5 n = 5 fn puts ) sub = // Execute fn with 'n' as argument and shows the result. ( 3 s = (s +) sub ) pr0 = ( 3 n = (n +) sub ) pr1 = pr0 // Shows 8 as expected. pr1 // Shows unexpectedly 10. pr1 fails because when in sub the reference of n is searched, the value 5 is found before 3 . For fix that there are two ways (see Symbol # ): 1 ( fn = # 5 n# = // Make n unique. n# fn puts ) sub = ( 3 n = (n +) sub ) pr1 = pr1 // Shows 8. 2 ( fn = 5 n = n fn puts ) sub = ( # 3 n# = // Make n unique. (n# +) sub ) pr1 = pr1 // Shows 8. The first way is better because avoid complications to the procedure client. Also is posible a more complicated form: ( fn = # 5 n# = // Make n unique. n# fn puts ) sub = ( # 3 n# = // Make n unique. (n# +) sub ) pr1 = pr1 // Shows 8.","title":"Virtual Machine"},{"location":"virtualMachine/#structure","text":"A virtual machine processes a token of type Procedure. Each virtual machine have: A stack (implemented as a pointer to a slice of tokens). A heap (implemented as a map from symbol to token). A list of modules imported (implemented as a slice of symbols). Virtual machines can run other ones. In such case: The stack can be inherited (normal case) or not (isolate machine). The heap is never inherited. The list of modules imported is ever inherited.","title":"Structure"},{"location":"virtualMachine/#working","text":"The virtual machine process a procedure token by token with the following steps: The token is a symbol: Is = ?: Raise an error. Is ?: Skip the token. Is a global symbol?: It is run. It is a primitive module?: Next token, that must be a symbol, is read and run. It is an imported module?: Next token, that must be a symbol, is read and then: If the last symbol is defined in the import: If it references a procedure: If an fallows: The procedure is pushed into the stack. Otherwise: The procedure is run. Otherwise the token referenced is pushed into the stack. Otherwise an error is raised. It is a module in heap?: If it references a procedure: If an fallows: The procedure is pushed into the stack. Otherwise: The procedure is run. Otherwise the token referenced is pushed into the stack. It is followed by = ?: The token is put into the heap. Otherwise an error is raised (\"unknown symbol\") Otherwise is pushed into the stack. NOTE: Observe that is not possible to redefine (push into heap) a symbol.","title":"Working"},{"location":"virtualMachine/#normal-and-isolate-virtual-machine","text":"A normal virtual machine share its stack with the virtual machine which call it. An isolate virtual machine has its own stack.","title":"Normal And Isolate Virtual Machine"},{"location":"virtualMachine/#heap-access","text":"Virtual machines create an call other virtual machines to execute procedures. This sets a hierarchy m1 - m2 - ... - mN. When a machine finds reference for a symbol, it accesses orderly the heap of every ancestor. A problem can apear when a procedure is send to be executed by other virtual machine. Let see the following program. ( fn = 5 n = 5 fn puts ) sub = // Execute fn with 'n' as argument and shows the result. ( 3 s = (s +) sub ) pr0 = ( 3 n = (n +) sub ) pr1 = pr0 // Shows 8 as expected. pr1 // Shows unexpectedly 10. pr1 fails because when in sub the reference of n is searched, the value 5 is found before 3 . For fix that there are two ways (see Symbol # ): 1 ( fn = # 5 n# = // Make n unique. n# fn puts ) sub = ( 3 n = (n +) sub ) pr1 = pr1 // Shows 8. 2 ( fn = 5 n = n fn puts ) sub = ( # 3 n# = // Make n unique. (n# +) sub ) pr1 = pr1 // Shows 8. The first way is better because avoid complications to the procedure client. Also is posible a more complicated form: ( fn = # 5 n# = // Make n unique. n# fn puts ) sub = ( # 3 n# = // Make n unique. (n# +) sub ) pr1 = pr1 // Shows 8.","title":"Heap Access"}]}